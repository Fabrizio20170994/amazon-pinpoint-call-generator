"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCryptoStream = exports.nodeKdf = exports.curryCryptoStream = exports.getDecryptionHelper = exports.getEncryptHelper = void 0;
const material_management_1 = require("@aws-crypto/material-management");
const crypto_1 = require("crypto");
const hkdf_node_1 = require("@aws-crypto/hkdf-node");
const serialize_1 = require("@aws-crypto/serialize");
const kdfIndex = Object.freeze({
    sha256: hkdf_node_1.HKDF('sha256'),
    sha384: hkdf_node_1.HKDF('sha384'),
    sha512: hkdf_node_1.HKDF('sha512'),
});
const getEncryptHelper = (material) => {
    /* Precondition: NodeEncryptionMaterial must have a valid data key. */
    material_management_1.needs(material.hasValidKey(), 'Material has no unencrypted data key.');
    const { signatureHash } = material.suite;
    /* Conditional types can not narrow the return type :(
     * Function overloads "works" but then I can not export
     * the function and have eslint be happy (Multiple exports of name)
     */
    /** @deprecated use getCipherInfo */
    const kdfGetCipher = getCryptoStream(material);
    const getCipherInfo = curryCryptoStream(material, crypto_1.createCipheriv);
    return Object.freeze({
        kdfGetCipher,
        getCipherInfo,
        getSigner: signatureHash ? getSigner : undefined,
        dispose,
    });
    function getSigner() {
        /* Precondition: The NodeEncryptionMaterial must have not been zeroed.
         * hasUnencryptedDataKey will check that the unencrypted data key has been set
         * *and* that it has not been zeroed.  At this point it must have been set
         * because the KDF function operated on it.  So at this point
         * we are protecting that someone has zeroed out the material
         * because the Encrypt process has been complete.
         */
        material_management_1.needs(material.hasUnencryptedDataKey, 'Unencrypted data key has been zeroed.');
        if (!signatureHash)
            throw new Error('Material does not support signature.');
        const { signatureKey } = material;
        if (!signatureKey)
            throw new Error('Material does not support signature.');
        const { privateKey } = signatureKey;
        if (typeof privateKey !== 'string')
            throw new Error('Material does not support signature.');
        const signer = Object.assign(crypto_1.createSign(signatureHash), 
        // don't export the private key if we don't have to
        { awsCryptoSign: () => signer.sign(privateKey) });
        return signer;
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
exports.getEncryptHelper = getEncryptHelper;
const getDecryptionHelper = (material) => {
    /* Precondition: NodeDecryptionMaterial must have a valid data key. */
    material_management_1.needs(material.hasValidKey(), 'Material has no unencrypted data key.');
    const { signatureHash } = material.suite;
    /* Conditional types can not narrow the return type :(
     * Function overloads "works" but then I can not export
     * the function and have eslint be happy (Multiple exports of name)
     */
    /** @deprecated use getDecipherInfo */
    const kdfGetDecipher = getCryptoStream(material);
    const getDecipherInfo = curryCryptoStream(material, crypto_1.createDecipheriv);
    return Object.freeze({
        kdfGetDecipher,
        getDecipherInfo,
        getVerify: signatureHash ? getVerify : undefined,
        dispose,
    });
    function getVerify() {
        if (!signatureHash)
            throw new Error('Material does not support signature.');
        const { verificationKey } = material;
        if (!verificationKey)
            throw new Error('Material does not support signature.');
        const verify = Object.assign(crypto_1.createVerify(signatureHash), 
        // explicitly bind the public key for this material
        {
            awsCryptoVerify: (signature) => 
            // As typescript gets better typing
            // We should consider either generics or
            // 2 different verificationKeys for Node and WebCrypto
            verify.verify(verificationKey.publicKey, signature),
        });
        return verify;
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
exports.getDecryptionHelper = getDecryptionHelper;
function curryCryptoStream(material, createCryptoIvStream) {
    const { encryption: cipherName, ivLength } = material.suite;
    const isEncrypt = material instanceof material_management_1.NodeEncryptionMaterial;
    /* Precondition: material must be either NodeEncryptionMaterial or NodeDecryptionMaterial.
     *
     */
    material_management_1.needs(isEncrypt
        ? crypto_1.createCipheriv === createCryptoIvStream
        : material instanceof material_management_1.NodeDecryptionMaterial
            ? crypto_1.createDecipheriv === createCryptoIvStream
            : false, 'Unsupported cryptographic material.');
    return (messageId, commitKey) => {
        const { derivedKey, keyCommitment } = nodeKdf(material, messageId, commitKey);
        return (isEncrypt
            ? { getCipher: createCryptoStream, keyCommitment }
            : createCryptoStream);
        function createCryptoStream(iv) {
            /* Precondition: The length of the IV must match the NodeAlgorithmSuite specification. */
            material_management_1.needs(iv.byteLength === ivLength, 'Iv length does not match algorithm suite specification');
            /* Precondition: The material must have not been zeroed.
             * hasUnencryptedDataKey will check that the unencrypted data key has been set
             * *and* that it has not been zeroed.  At this point it must have been set
             * because the KDF function operated on it.  So at this point
             * we are protecting that someone has zeroed out the material
             * because the Encrypt process has been complete.
             */
            material_management_1.needs(material.hasUnencryptedDataKey, 'Unencrypted data key has been zeroed.');
            /* createDecipheriv is incorrectly typed in @types/node. It should take key: CipherKey, not key: BinaryLike.
             * Also, the check above ensures
             * that _createCryptoStream is not false.
             * But TypeScript does not believe me.
             * For any complicated code,
             * you should defer to the checker,
             * but here I'm going to assert
             * it is simple enough.
             */
            return createCryptoIvStream(cipherName, derivedKey, iv);
        }
    };
}
exports.curryCryptoStream = curryCryptoStream;
function nodeKdf(material, nonce, commitKey) {
    const dataKey = material.getUnencryptedDataKey();
    const { kdf, kdfHash, keyLengthBytes, commitmentLength, saltLengthBytes, commitment, id: suiteId, } = material.suite;
    /* Check for early return (Postcondition): No Node.js KDF, just return the unencrypted data key. */
    if (!kdf && !kdfHash) {
        /* Postcondition: Non-KDF algorithm suites *must* not have a commitment. */
        material_management_1.needs(!commitKey, 'Commitment not supported.');
        return { derivedKey: dataKey };
    }
    /* Precondition: Valid HKDF values must exist for Node.js. */
    material_management_1.needs(kdf === 'HKDF' &&
        kdfHash &&
        kdfIndex[kdfHash] &&
        nonce instanceof Uint8Array, 'Invalid HKDF values.');
    /* The unwrap is done once we *know* that a KDF is required.
     * If we unwrapped before everything will work,
     * but we may be creating new copies of the unencrypted data key (export).
     */
    const { buffer: dkBuffer, byteOffset: dkByteOffset, byteLength: dkByteLength, } = material_management_1.unwrapDataKey(dataKey);
    if (commitment === 'NONE') {
        /* Postcondition: Non-committing Node algorithm suites *must* not have a commitment. */
        material_management_1.needs(!commitKey, 'Commitment not supported.');
        const toExtract = Buffer.from(dkBuffer, dkByteOffset, dkByteLength);
        const { buffer, byteOffset, byteLength } = serialize_1.kdfInfo(suiteId, nonce);
        const infoBuff = Buffer.from(buffer, byteOffset, byteLength);
        const derivedBytes = kdfIndex[kdfHash](toExtract)(keyLengthBytes, infoBuff);
        const derivedKey = material_management_1.wrapWithKeyObjectIfSupported(derivedBytes);
        return { derivedKey };
    }
    /* Precondition UNTESTED: Committing suites must define expected values. */
    material_management_1.needs(commitment === 'KEY' && commitmentLength && saltLengthBytes, 'Malformed suite data.');
    /* Precondition: For committing algorithms, the nonce *must* be 256 bit.
     * i.e. It must target a V2 message format.
     */
    material_management_1.needs(nonce.byteLength === saltLengthBytes, 'Nonce is not the correct length for committed algorithm suite.');
    const toExtract = Buffer.from(dkBuffer, dkByteOffset, dkByteLength);
    const expand = kdfIndex[kdfHash](toExtract, nonce);
    const { keyLabel, commitLabel } = serialize_1.kdfCommitKeyInfo(material.suite);
    const keyCommitment = expand(commitmentLength / 8, commitLabel);
    const isDecrypt = material instanceof material_management_1.NodeDecryptionMaterial;
    /* Precondition: If material is NodeDecryptionMaterial the key commitments *must* match.
     * This is also the preferred location to check,
     * because then the decryption key is never even derived.
     */
    material_management_1.needs((isDecrypt && commitKey && crypto_1.timingSafeEqual(keyCommitment, commitKey)) ||
        (!isDecrypt && !commitKey), isDecrypt ? 'Commitment does not match.' : 'Invalid arguments.');
    const derivedBytes = expand(keyLengthBytes, keyLabel);
    const derivedKey = material_management_1.wrapWithKeyObjectIfSupported(derivedBytes);
    return { derivedKey, keyCommitment };
}
exports.nodeKdf = nodeKdf;
/** @deprecated use curryCryptoStream */
function getCryptoStream(material) {
    const { encryption: cipherName, ivLength } = material.suite;
    const createCryptoStream = material instanceof material_management_1.NodeEncryptionMaterial
        ? crypto_1.createCipheriv
        : material instanceof material_management_1.NodeDecryptionMaterial
            ? crypto_1.createDecipheriv
            : false;
    /* : material must be either NodeEncryptionMaterial or NodeDecryptionMaterial. */
    if (!createCryptoStream)
        throw new Error('Unsupported cryptographic material.');
    return (info) => {
        /* This function expected to always be passed the info,
         * not the messageId.
         * I'm going to deprecate this function soon,
         * and no one should be using it.
         */
        const derivedKey = nodeKdf(material, info.slice(2)).derivedKey;
        return (iv) => {
            /* : The length of the IV must match the NodeAlgorithmSuite specification. */
            material_management_1.needs(iv.byteLength === ivLength, 'Iv length does not match algorithm suite specification');
            /* : The material must have not been zeroed.
             * hasUnencryptedDataKey will check that the unencrypted data key has been set
             * *and* that it has not been zeroed.  At this point it must have been set
             * because the KDF function operated on it.  So at this point
             * we are protecting that someone has zeroed out the material
             * because the Encrypt process has been complete.
             */
            material_management_1.needs(material.hasUnencryptedDataKey, 'Unencrypted data key has been zeroed.');
            // createDecipheriv is incorrectly typed in @types/node. It should take key: CipherKey, not key: BinaryLike
            return createCryptoStream(cipherName, derivedKey, iv);
        };
    };
}
exports.getCryptoStream = getCryptoStream;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWxfaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYXRlcmlhbF9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxvRUFBb0U7QUFDcEUsc0NBQXNDOzs7QUFFdEMseUVBUXdDO0FBQ3hDLG1DQVFlO0FBQ2YscURBQTRDO0FBQzVDLHFEQUFpRTtBQWlCakUsTUFBTSxRQUFRLEdBQWEsTUFBTSxDQUFDLE1BQU0sQ0FBQztJQUN2QyxNQUFNLEVBQUUsZ0JBQUksQ0FBQyxRQUFvQixDQUFDO0lBQ2xDLE1BQU0sRUFBRSxnQkFBSSxDQUFDLFFBQW9CLENBQUM7SUFDbEMsTUFBTSxFQUFFLGdCQUFJLENBQUMsUUFBb0IsQ0FBQztDQUNuQyxDQUFDLENBQUE7QUFrQ0ssTUFBTSxnQkFBZ0IsR0FBcUIsQ0FDaEQsUUFBZ0MsRUFDaEMsRUFBRTtJQUNGLHNFQUFzRTtJQUN0RSwyQkFBSyxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsRUFBRSx1Q0FBdUMsQ0FBQyxDQUFBO0lBRXRFLE1BQU0sRUFBRSxhQUFhLEVBQUUsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFBO0lBQ3hDOzs7T0FHRztJQUNILG9DQUFvQztJQUNwQyxNQUFNLFlBQVksR0FBRyxlQUFlLENBQUMsUUFBUSxDQUFtQixDQUFBO0lBQ2hFLE1BQU0sYUFBYSxHQUFHLGlCQUFpQixDQUFDLFFBQVEsRUFBRSx1QkFBYyxDQUFDLENBQUE7SUFDakUsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ25CLFlBQVk7UUFDWixhQUFhO1FBQ2IsU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTO1FBQ2hELE9BQU87S0FDUixDQUFDLENBQUE7SUFFRixTQUFTLFNBQVM7UUFDaEI7Ozs7OztXQU1HO1FBQ0gsMkJBQUssQ0FDSCxRQUFRLENBQUMscUJBQXFCLEVBQzlCLHVDQUF1QyxDQUN4QyxDQUFB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