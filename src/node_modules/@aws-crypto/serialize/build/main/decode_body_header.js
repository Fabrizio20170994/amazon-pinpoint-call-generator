"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeNonFrameBodyHeader = exports.decodeFinalFrameBodyHeader = exports.decodeFrameBodyHeader = exports.decodeBodyHeader = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const identifiers_1 = require("./identifiers");
const material_management_1 = require("@aws-crypto/material-management");
/*
 * This public interface for reading the BodyHeader format is provided for
 * the use of the Encryption SDK for JavaScript only.  It can be used
 * as a reference but is not intended to be use by any packages other
 * than the Encryption SDK for JavaScript.
 *
 * See:
 * https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#body-framing
 * https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#body-no-framing
 */
/**
 * decodeBodyHeader
 *
 * I need to be able to parse the BodyHeader, but since the data may be streamed
 * I may not have all the data yet.  The caller is expected to maintain and append
 * to the buffer and call this function with the same readPos until the function
 * returns a BodyHeader.
 *
 * @param buffer Uint8Array
 * @param headerInfo HeaderInfo
 * @param readPos number
 * @returns BodyHeader|false
 */
function decodeBodyHeader(buffer, headerInfo, readPos) {
    /* Precondition: The contentType must be a supported format. */
    material_management_1.needs(identifiers_1.ContentType[headerInfo.messageHeader.contentType], 'Unknown contentType');
    switch (headerInfo.messageHeader.contentType) {
        case identifiers_1.ContentType.FRAMED_DATA:
            return decodeFrameBodyHeader(buffer, headerInfo, readPos);
        case identifiers_1.ContentType.NO_FRAMING:
            return decodeNonFrameBodyHeader(buffer, headerInfo, readPos);
    }
    return false;
}
exports.decodeBodyHeader = decodeBodyHeader;
/**
 *  Exported for testing.  Used by decodeBodyHeader to compose a complete solution.
 * @param buffer Uint8Array
 * @param headerInfo HeaderInfo
 * @param readPos number
 */
function decodeFrameBodyHeader(buffer, headerInfo, readPos) {
    /* Precondition: The contentType must be FRAMED_DATA. */
    material_management_1.needs(identifiers_1.ContentType.FRAMED_DATA === headerInfo.messageHeader.contentType, 'Unknown contentType');
    const { frameLength } = headerInfo.messageHeader;
    const { ivLength, tagLength } = headerInfo.algorithmSuite;
    /* Uint8Array is a view on top of the underlying ArrayBuffer.
     * This means that raw underlying memory stored in the ArrayBuffer
     * may be larger than the Uint8Array.  This is especially true of
     * the Node.js Buffer object.  The offset and length *must* be
     * passed to the DataView otherwise I will get unexpected results.
     */
    const dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    /* Precondition: decodeFrameBodyHeader readPos must be within the byte length of the buffer given. */
    material_management_1.needs(dataView.byteLength >= readPos && readPos >= 0, 'readPos out of bounds.');
    /* Check for early return (Postcondition): There must be enough data to decodeFrameBodyHeader.
     * The format expressed here is
     * SequenceIdentifier: Uint32
     * IVLength: Uint8
     * There is a special case where the SequenceIdentifier is the Final Frame.
     */
    if (4 + ivLength + readPos > dataView.byteLength)
        return false;
    const sequenceNumber = dataView.getUint32(readPos);
    /* Postcondition: decodeFrameBodyHeader sequenceNumber must be greater than 0. */
    material_management_1.needs(sequenceNumber > 0, 'Malformed sequenceNumber.');
    if (sequenceNumber === identifiers_1.SequenceIdentifier.SEQUENCE_NUMBER_END) {
        return decodeFinalFrameBodyHeader(buffer, headerInfo, readPos);
    }
    const iv = buffer.slice((readPos += 4), (readPos += ivLength));
    return {
        sequenceNumber,
        iv,
        contentLength: frameLength,
        readPos,
        tagLength,
        isFinalFrame: false,
        contentType: identifiers_1.ContentType.FRAMED_DATA,
    };
}
exports.decodeFrameBodyHeader = decodeFrameBodyHeader;
/**
 *  Exported for testing.  Used by decodeBodyHeader to compose a complete solution.
 * @param buffer Uint8Array
 * @param headerInfo HeaderInfo
 * @param readPos number
 */
function decodeFinalFrameBodyHeader(buffer, headerInfo, readPos) {
    /* Precondition: The contentType must be FRAMED_DATA to be a Final Frame. */
    material_management_1.needs(identifiers_1.ContentType.FRAMED_DATA === headerInfo.messageHeader.contentType, 'Unknown contentType');
    const { ivLength, tagLength } = headerInfo.algorithmSuite;
    /* Uint8Array is a view on top of the underlying ArrayBuffer.
     * This means that raw underlying memory stored in the ArrayBuffer
     * may be larger than the Uint8Array.  This is especially true of
     * the Node.js Buffer object.  The offset and length *must* be
     * passed to the DataView otherwise I will get unexpected results.
     */
    const dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    /* Precondition: decodeFinalFrameBodyHeader readPos must be within the byte length of the buffer given. */
    material_management_1.needs(dataView.byteLength >= readPos && readPos >= 0, 'readPos out of bounds.');
    /* Check for early return (Postcondition): There must be enough data to decodeFinalFrameBodyHeader.
     * The format expressed here is
     * SEQUENCE_NUMBER_END: Uint32(FFFF)
     * SequenceIdentifier: Uint32
     * IVLength: Uint8
     * Reserved: Uint32
     * ContentLength: Uint32
     */
    if (4 + 4 + ivLength + 4 + readPos > dataView.byteLength)
        return false;
    /* The precondition SEQUENCE_NUMBER_END: Uint32(FFFF) is handled above. */
    const sequenceEnd = dataView.getUint32(readPos, false); // big endian
    /* Postcondition: sequenceEnd must be SEQUENCE_NUMBER_END. */
    material_management_1.needs(sequenceEnd === identifiers_1.SequenceIdentifier.SEQUENCE_NUMBER_END, 'Malformed final frame: Invalid sequence number end value');
    const sequenceNumber = dataView.getUint32((readPos += 4), false); // big endian
    /* Postcondition: decodeFinalFrameBodyHeader sequenceNumber must be greater than 0. */
    material_management_1.needs(sequenceNumber > 0, 'Malformed sequenceNumber.');
    const iv = buffer.slice((readPos += 4), (readPos += ivLength));
    const contentLength = dataView.getUint32(readPos);
    /* Postcondition: The final frame MUST NOT exceed the frameLength. */
    material_management_1.needs(headerInfo.messageHeader.frameLength >= contentLength, 'Final frame length exceeds frame length.');
    return {
        sequenceNumber,
        iv,
        contentLength,
        readPos: readPos + 4,
        tagLength,
        isFinalFrame: true,
        contentType: identifiers_1.ContentType.FRAMED_DATA,
    };
}
exports.decodeFinalFrameBodyHeader = decodeFinalFrameBodyHeader;
/**
 * Exported for testing.  Used by decodeBodyHeader to compose a complete solution.
 * @param buffer Uint8Array
 * @param headerInfo HeaderInfo
 * @param readPos number
 */
function decodeNonFrameBodyHeader(buffer, headerInfo, readPos) {
    /* Precondition: The contentType must be NO_FRAMING. */
    material_management_1.needs(identifiers_1.ContentType.NO_FRAMING === headerInfo.messageHeader.contentType, 'Unknown contentType');
    const { ivLength, tagLength } = headerInfo.algorithmSuite;
    /* Uint8Array is a view on top of the underlying ArrayBuffer.
     * This means that raw underlying memory stored in the ArrayBuffer
     * may be larger than the Uint8Array.  This is especially true of
     * the Node.js Buffer object.  The offset and length *must* be
     * passed to the DataView otherwise I will get unexpected results.
     */
    const dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    /* Precondition: decodeNonFrameBodyHeader readPos must be within the byte length of the buffer given. */
    material_management_1.needs(dataView.byteLength >= readPos && readPos >= 0, 'readPos out of bounds.');
    /* Check for early return (Postcondition): There must be enough data to decodeNonFrameBodyHeader.
     * The format expressed here is
     * IVLength: Uint8
     * ContentLength: Uint64
     */
    if (ivLength + 8 + readPos > dataView.byteLength)
        return false;
    const iv = buffer.slice(readPos, (readPos += ivLength));
    const contentLengthBuff = buffer.slice(readPos, (readPos += 8));
    const contentLengthBN = new bn_js_1.default([...contentLengthBuff], 16, 'be');
    // This will throw if the number is larger than Number.MAX_SAFE_INTEGER.
    // i.e. a 53 bit number
    const contentLength = contentLengthBN.toNumber();
    /* Postcondition: Non-framed content length MUST NOT exceed AES-GCM safe limits.
     * https://github.com/awslabs/aws-encryption-sdk-specification/blob/master/data-format/message-body.md#encrypted-content-length
     */
    material_management_1.needs(identifiers_1.Maximum.BYTES_PER_AES_GCM_NONCE > contentLength, 'Content length out of bounds.');
    return {
        sequenceNumber: 1,
        iv,
        contentLength,
        readPos,
        tagLength,
        isFinalFrame: true,
        contentType: identifiers_1.ContentType.NO_FRAMING,
    };
}
exports.decodeNonFrameBodyHeader = decodeNonFrameBodyHeader;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb2RlX2JvZHlfaGVhZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2RlY29kZV9ib2R5X2hlYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsb0VBQW9FO0FBQ3BFLHNDQUFzQzs7Ozs7O0FBRXRDLGtEQUFzQjtBQUN0QiwrQ0FBd0U7QUFPeEUseUVBQXVEO0FBRXZEOzs7Ozs7Ozs7R0FTRztBQUVIOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILFNBQWdCLGdCQUFnQixDQUM5QixNQUFrQixFQUNsQixVQUFzQixFQUN0QixPQUFlO0lBRWYsK0RBQStEO0lBQy9ELDJCQUFLLENBQ0gseUJBQVcsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxFQUNqRCxxQkFBcUIsQ0FDdEIsQ0FBQTtJQUVELFFBQVEsVUFBVSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUU7UUFDNUMsS0FBSyx5QkFBVyxDQUFDLFdBQVc7WUFDMUIsT0FBTyxxQkFBcUIsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFBO1FBQzNELEtBQUsseUJBQVcsQ0FBQyxVQUFVO1lBQ3pCLE9BQU8sd0JBQXdCLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQTtLQUMvRDtJQUNELE9BQU8sS0FBSyxDQUFBO0FBQ2QsQ0FBQztBQWxCRCw0Q0FrQkM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLHFCQUFxQixDQUNuQyxNQUFrQixFQUNsQixVQUFzQixFQUN0QixPQUFlO0lBRWYsd0RBQXdEO0lBQ3hELDJCQUFLLENBQ0gseUJBQVcsQ0FBQyxXQUFXLEtBQUssVUFBVSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQ2hFLHFCQUFxQixDQUN0QixDQUFBO0lBRUQsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLFVBQVUsQ0FBQyxhQUFhLENBQUE7SUFDaEQsTUFBTSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsR0FBRyxVQUFVLENBQUMsY0FBYyxDQUFBO0lBRXpEOzs7OztPQUtHO0lBQ0gsTUFBTSxRQUFRLEdBQUcsSUFBSSxRQUFRLENBQzNCLE1BQU0sQ0FBQyxNQUFNLEVBQ2IsTUFBTSxDQUFDLFVBQVUsRUFDakIsTUFBTSxDQUFDLFVBQVUsQ0FDbEIsQ0FBQTtJQUVELHFHQUFxRztJQUNyRywyQkFBSyxDQUNILFFBQVEsQ0FBQyxVQUFVLElBQUksT0FBTyxJQUFJLE9BQU8sSUFBSSxDQUFDLEVBQzlDLHdCQUF3QixDQUN6QixDQUFBO0lBRUQ7Ozs7O09BS0c7SUFDSCxJQUFJLENBQUMsR0FBRyxRQUFRLEdBQUcsT0FBTyxHQUFHLFFBQVEsQ0FBQyxVQUFVO1FBQUUsT0FBTyxLQUFLLENBQUE7SUFFOUQsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQTtJQUNsRCxpRkFBaUY7SUFDakYsMkJBQUssQ0FBQyxjQUFjLEdBQUcsQ0FBQyxFQUFFLDJCQUEyQixDQUFDLENBQUE7SUFDdEQsSUFBSSxjQUFjLEtBQUssZ0NBQWtCLENBQUMsbUJBQW1CLEVBQUU7UUFDN0QsT0FBTywwQkFBMEIsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFBO0tBQy9EO0lBRUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFBO0lBQzlELE9BQU87UUFDTCxjQUFjO1FBQ2QsRUFBRTtRQUNGLGFBQWEsRUFBRSxXQUFXO1FBQzFCLE9BQU87UUFDUCxTQUFTO1FBQ1QsWUFBWSxFQUFFLEtBQUs7UUFDbkIsV0FBVyxFQUFFLHlCQUFXLENBQUMsV0FBVztLQUNyQyxDQUFBO0FBQ0gsQ0FBQztBQXpERCxzREF5REM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLDBCQUEwQixDQUN4QyxNQUFrQixFQUNsQixVQUFzQixFQUN0QixPQUFlO0lBRWYsNEVBQTRFO0lBQzVFLDJCQUFLLENBQ0gseUJBQVcsQ0FBQyxXQUFXLEtBQUssVUFBVSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQ2hFLHFCQUFxQixDQUN0QixDQUFBO0lBRUQsTUFBTSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsR0FBRyxVQUFVLENBQUMsY0FBYyxDQUFBO0lBRXpEOzs7OztPQUtHO0lBQ0gsTUFBTSxRQUFRLEdBQUcsSUFBSSxRQUFRLENBQzNCLE1BQU0sQ0FBQyxNQUFNLEVBQ2IsTUFBTSxDQUFDLFVBQVUsRUFDakIsTUFBTSxDQUFDLFVBQVUsQ0FDbEIsQ0FBQTtJQUVELDBHQUEwRztJQUMxRywyQkFBSyxDQUNILFFBQVEsQ0FBQyxVQUFVLElBQUksT0FBTyxJQUFJLE9BQU8sSUFBSSxDQUFDLEVBQzlDLHdCQUF3QixDQUN6QixDQUFBO0lBQ0Q7Ozs7Ozs7T0FPRztJQUNILElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxRQUFRLEdBQUcsQ0FBQyxHQUFHLE9BQU8sR0FBRyxRQUFRLENBQUMsVUFBVTtRQUFFLE9BQU8sS0FBSyxDQUFBO0lBRXRFLDBFQUEwRTtJQUMxRSxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQSxDQUFDLGFBQWE7SUFDcEUsNkRBQTZEO0lBQzdELDJCQUFLLENBQ0gsV0FBVyxLQUFLLGdDQUFrQixDQUFDLG1CQUFtQixFQUN0RCwwREFBMEQsQ0FDM0QsQ0FBQTtJQUNELE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUEsQ0FBQyxhQUFhO0lBQzlFLHNGQUFzRjtJQUN0RiwyQkFBSyxDQUFDLGNBQWMsR0FBRyxDQUFDLEVBQUUsMkJBQTJCLENBQUMsQ0FBQTtJQUN0RCxNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUE7SUFDOUQsTUFBTSxhQUFhLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQTtJQUNqRCxxRUFBcUU7SUFDckUsMkJBQUssQ0FDSCxVQUFVLENBQUMsYUFBYSxDQUFDLFdBQVcsSUFBSSxhQUFhLEVBQ3JELDBDQUEwQyxDQUMzQyxDQUFBO0lBQ0QsT0FBTztRQUNMLGNBQWM7UUFDZCxFQUFFO1FBQ0YsYUFBYTtRQUNiLE9BQU8sRUFBRSxPQUFPLEdBQUcsQ0FBQztRQUNwQixTQUFTO1FBQ1QsWUFBWSxFQUFFLElBQUk7UUFDbEIsV0FBVyxFQUFFLHlCQUFXLENBQUMsV0FBVztLQUNyQyxDQUFBO0FBQ0gsQ0FBQztBQWxFRCxnRUFrRUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLHdCQUF3QixDQUN0QyxNQUFrQixFQUNsQixVQUFzQixFQUN0QixPQUFlO0lBRWYsdURBQXVEO0lBQ3ZELDJCQUFLLENBQ0gseUJBQVcsQ0FBQyxVQUFVLEtBQUssVUFBVSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQy9ELHFCQUFxQixDQUN0QixDQUFBO0lBRUQsTUFBTSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsR0FBRyxVQUFVLENBQUMsY0FBYyxDQUFBO0lBRXpEOzs7OztPQUtHO0lBQ0gsTUFBTSxRQUFRLEdBQUcsSUFBSSxRQUFRLENBQzNCLE1BQU0sQ0FBQyxNQUFNLEVBQ2IsTUFBTSxDQUFDLFVBQVUsRUFDakIsTUFBTSxDQUFDLFVBQVUsQ0FDbEIsQ0FBQTtJQUVELHdHQUF3RztJQUN4RywyQkFBSyxDQUNILFFBQVEsQ0FBQyxVQUFVLElBQUksT0FBTyxJQUFJLE9BQU8sSUFBSSxDQUFDLEVBQzlDLHdCQUF3QixDQUN6QixDQUFBO0lBRUQ7Ozs7T0FJRztJQUNILElBQUksUUFBUSxHQUFHLENBQUMsR0FBRyxPQUFPLEdBQUcsUUFBUSxDQUFDLFVBQVU7UUFBRSxPQUFPLEtBQUssQ0FBQTtJQUU5RCxNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFBO0lBQ3ZELE1BQU0saUJBQWlCLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQTtJQUMvRCxNQUFNLGVBQWUsR0FBRyxJQUFJLGVBQUUsQ0FBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUE7SUFDaEUsd0VBQXdFO0lBQ3hFLHVCQUF1QjtJQUN2QixNQUFNLGFBQWEsR0FBRyxlQUFlLENBQUMsUUFBUSxFQUFFLENBQUE7SUFDaEQ7O09BRUc7SUFDSCwyQkFBSyxDQUNILHFCQUFPLENBQUMsdUJBQXVCLEdBQUcsYUFBYSxFQUMvQywrQkFBK0IsQ0FDaEMsQ0FBQTtJQUNELE9BQU87UUFDTCxjQUFjLEVBQUUsQ0FBQztRQUNqQixFQUFFO1FBQ0YsYUFBYTtRQUNiLE9BQU87UUFDUCxTQUFTO1FBQ1QsWUFBWSxFQUFFLElBQUk7UUFDbEIsV0FBVyxFQUFFLHlCQUFXLENBQUMsVUFBVTtLQUNwQyxDQUFBO0FBQ0gsQ0FBQztBQTVERCw0REE0REMifQ==