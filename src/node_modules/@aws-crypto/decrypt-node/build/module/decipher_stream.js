// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
// @ts-ignore
import { Transform as PortableTransform } from 'readable-stream';
import { needs, } from '@aws-crypto/material-management-node';
import { aadFactory } from '@aws-crypto/serialize';
import { VerifyStream } from './verify_stream';
const fromUtf8 = (input) => Buffer.from(input, 'utf8');
const aadUtility = aadFactory(fromUtf8);
const PortableTransformWithType = PortableTransform;
const ioTick = async () => new Promise((resolve) => setImmediate(resolve));
const noop = () => { }; // eslint-disable-line @typescript-eslint/no-empty-function
export function getDecipherStream() {
    let decipherInfo;
    let decipherState = {};
    let pathologicalDrain = noop;
    let frameComplete = false;
    return new (class DecipherStream extends PortableTransformWithType {
        constructor() {
            super();
            this._onBodyHeader = ({ iv, contentLength, sequenceNumber, isFinalFrame, }) => {
                /* Precondition: decipherInfo must be set before BodyInfo is sent. */
                needs(decipherInfo, 'Malformed State.');
                /* Precondition: Ciphertext must not be flowing before a BodyHeader is processed. */
                needs(!decipherState.decipher, 'Malformed State.');
                const { messageId, contentType, getDecipher } = decipherInfo;
                const aadString = aadUtility.messageAADContentString({
                    contentType,
                    isFinalFrame,
                });
                const messageAAD = aadUtility.messageAAD(messageId, aadString, sequenceNumber, contentLength);
                const decipher = getDecipher(iv).setAAD(Buffer.from(messageAAD.buffer, messageAAD.byteOffset, messageAAD.byteLength));
                const content = [];
                decipherState = { decipher, content, contentLength };
            };
            this._onAuthTag = async (authTag, next) => {
                const { decipher, content, contentLength } = decipherState;
                /* Precondition: _onAuthTag must be called only after a frame has been accumulated.
                 * However there is an edge case.  The final frame _can_ be zero length.
                 * This means that _transform will never be called.
                 */
                needs(frameComplete || contentLength === 0, 'AuthTag before frame.');
                /* Precondition UNTESTED: I must have received all content for this frame.
                 * Both contentLength and frameComplete are private variables.
                 * As such manipulating them separately outside of the _transform function
                 * should not be possible.
                 * I do not know of this condition would ever be false while the above is true.
                 * But I do not want to remove the check as there may be a more complicated case
                 * that makes this possible.
                 * If such a case is found.
                 * Write a test.
                 */
                needs(contentLength === 0, 'Lengths do not match');
                // flush content from state.
                decipherState = {};
                decipher.setAuthTag(authTag);
                /* In Node.js versions 10.9 and older will fail to decrypt if decipher.update is not called.
                 * https://github.com/nodejs/node/pull/22538 fixes this.
                 */
                if (!content.length)
                    decipher.update(Buffer.alloc(0));
                const clear = [];
                for (const cipherChunk of content) {
                    const clearChunk = decipher.update(cipherChunk);
                    clear.push(clearChunk);
                    await ioTick();
                }
                // If the authTag is not valid this will throw
                const tail = decipher.final();
                clear.push(tail);
                for (const clearChunk of clear) {
                    if (!this.push(clearChunk)) {
                        /* back pressure: if push returns false, wait until _read
                         * has been called.
                         */
                        await new Promise((resolve) => {
                            pathologicalDrain = resolve;
                        });
                    }
                }
                /* This frame is complete.
                 * Need to notify the VerifyStream continue.
                 * See the note in `AuthTag` for details.
                 * The short answer is that for small frame sizes,
                 * the "next" frame associated auth tag may be
                 * parsed and send before the "current" is processed.
                 * This will cause the auth tag event to fire before
                 * any _transform events fire and a 'Lengths do not match' precondition to fail.
                 */
                next();
                // This frame is complete. Notify _transform to continue, see needs above for more details
                if (frameComplete)
                    frameComplete();
                // reset for next frame.
                frameComplete = false;
            };
            this.on('pipe', (source) => {
                /* Precondition: The source must be a VerifyStream to emit the required events. */
                needs(source instanceof VerifyStream, 'Unsupported source');
                source
                    .once('DecipherInfo', (info) => {
                    decipherInfo = info;
                })
                    .on('BodyInfo', this._onBodyHeader)
                    .on('AuthTag', (authTag, next) => {
                    this._onAuthTag(authTag, next).catch((e) => this.emit('error', e));
                });
            });
        }
        _transform(chunk, _encoding, callback) {
            /* Precondition: BodyHeader must be parsed before frame data. */
            needs(decipherState.decipher, 'Malformed State.');
            decipherState.contentLength -= chunk.length;
            /* Precondition: Only content should be transformed, so the lengths must always match.
             * The BodyHeader and AuthTag are striped in the VerifyStream and passed in
             * through events.  This means that if I receive a chunk without having reset
             * the content accumulation events are out of order.  Panic.
             */
            needs(decipherState.contentLength >= 0, 'Lengths do not match');
            const { content } = decipherState;
            content.push(chunk);
            if (decipherState.contentLength > 0) {
                // More data to this frame
                callback();
            }
            else {
                // The frame is full, waiting for `AuthTag`
                // event to decrypt and forward the clear frame
                frameComplete = callback;
            }
        }
        _read(size) {
            /* The _onAuthTag decrypts and pushes the encrypted frame.
             * If this.push returns false then this stream
             * should wait until the destination stream calls read.
             * This means that _onAuthTag needs to wait for some
             * indeterminate time.  I create a closure around
             * the resolution function for a promise that
             * is created in _onAuthTag.  This way
             * here in _read (the implementation of read)
             * if a frame is being pushed, we can release
             * it.
             */
            pathologicalDrain();
            pathologicalDrain = noop;
            super._read(size);
        }
        _destroy() {
            // It is possible to have to destroy the stream before
            // decipherInfo is set.  Especially if the HeaderAuth
            // is not valid.
            decipherInfo && decipherInfo.dispose();
        }
    })();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjaXBoZXJfc3RyZWFtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2RlY2lwaGVyX3N0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxvRUFBb0U7QUFDcEUsc0NBQXNDO0FBRXRDLGFBQWE7QUFDYixPQUFPLEVBQUUsU0FBUyxJQUFJLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUE7QUFFaEUsT0FBTyxFQUNMLEtBQUssR0FHTixNQUFNLHNDQUFzQyxDQUFBO0FBQzdDLE9BQU8sRUFBRSxVQUFVLEVBQWUsTUFBTSx1QkFBdUIsQ0FBQTtBQUMvRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUE7QUFFOUMsTUFBTSxRQUFRLEdBQUcsQ0FBQyxLQUFhLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFBO0FBQzlELE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQUN2QyxNQUFNLHlCQUF5QixHQUFHLGlCQUVwQixDQUFBO0FBc0JkLE1BQU0sTUFBTSxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFBO0FBQzFFLE1BQU0sSUFBSSxHQUFHLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQSxDQUFDLDJEQUEyRDtBQUVqRixNQUFNLFVBQVUsaUJBQWlCO0lBQy9CLElBQUksWUFBMEIsQ0FBQTtJQUM5QixJQUFJLGFBQWEsR0FBa0IsRUFBUyxDQUFBO0lBQzVDLElBQUksaUJBQWlCLEdBQTJCLElBQUksQ0FBQTtJQUNwRCxJQUFJLGFBQWEsR0FBb0MsS0FBSyxDQUFBO0lBRTFELE9BQU8sSUFBSSxDQUFDLE1BQU0sY0FBZSxTQUFRLHlCQUF5QjtRQUNoRTtZQUNFLEtBQUssRUFBRSxDQUFBO1lBZVQs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