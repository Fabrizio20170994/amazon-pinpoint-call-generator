"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDecipherStream = void 0;
// @ts-ignore
const readable_stream_1 = require("readable-stream");
const material_management_node_1 = require("@aws-crypto/material-management-node");
const serialize_1 = require("@aws-crypto/serialize");
const verify_stream_1 = require("./verify_stream");
const fromUtf8 = (input) => Buffer.from(input, 'utf8');
const aadUtility = serialize_1.aadFactory(fromUtf8);
const PortableTransformWithType = readable_stream_1.Transform;
const ioTick = async () => new Promise((resolve) => setImmediate(resolve));
const noop = () => { }; // eslint-disable-line @typescript-eslint/no-empty-function
function getDecipherStream() {
    let decipherInfo;
    let decipherState = {};
    let pathologicalDrain = noop;
    let frameComplete = false;
    return new (class DecipherStream extends PortableTransformWithType {
        constructor() {
            super();
            this._onBodyHeader = ({ iv, contentLength, sequenceNumber, isFinalFrame, }) => {
                /* Precondition: decipherInfo must be set before BodyInfo is sent. */
                material_management_node_1.needs(decipherInfo, 'Malformed State.');
                /* Precondition: Ciphertext must not be flowing before a BodyHeader is processed. */
                material_management_node_1.needs(!decipherState.decipher, 'Malformed State.');
                const { messageId, contentType, getDecipher } = decipherInfo;
                const aadString = aadUtility.messageAADContentString({
                    contentType,
                    isFinalFrame,
                });
                const messageAAD = aadUtility.messageAAD(messageId, aadString, sequenceNumber, contentLength);
                const decipher = getDecipher(iv).setAAD(Buffer.from(messageAAD.buffer, messageAAD.byteOffset, messageAAD.byteLength));
                const content = [];
                decipherState = { decipher, content, contentLength };
            };
            this._onAuthTag = async (authTag, next) => {
                const { decipher, content, contentLength } = decipherState;
                /* Precondition: _onAuthTag must be called only after a frame has been accumulated.
                 * However there is an edge case.  The final frame _can_ be zero length.
                 * This means that _transform will never be called.
                 */
                material_management_node_1.needs(frameComplete || contentLength === 0, 'AuthTag before frame.');
                /* Precondition UNTESTED: I must have received all content for this frame.
                 * Both contentLength and frameComplete are private variables.
                 * As such manipulating them separately outside of the _transform function
                 * should not be possible.
                 * I do not know of this condition would ever be false while the above is true.
                 * But I do not want to remove the check as there may be a more complicated case
                 * that makes this possible.
                 * If such a case is found.
                 * Write a test.
                 */
                material_management_node_1.needs(contentLength === 0, 'Lengths do not match');
                // flush content from state.
                decipherState = {};
                decipher.setAuthTag(authTag);
                /* In Node.js versions 10.9 and older will fail to decrypt if decipher.update is not called.
                 * https://github.com/nodejs/node/pull/22538 fixes this.
                 */
                if (!content.length)
                    decipher.update(Buffer.alloc(0));
                const clear = [];
                for (const cipherChunk of content) {
                    const clearChunk = decipher.update(cipherChunk);
                    clear.push(clearChunk);
                    await ioTick();
                }
                // If the authTag is not valid this will throw
                const tail = decipher.final();
                clear.push(tail);
                for (const clearChunk of clear) {
                    if (!this.push(clearChunk)) {
                        /* back pressure: if push returns false, wait until _read
                         * has been called.
                         */
                        await new Promise((resolve) => {
                            pathologicalDrain = resolve;
                        });
                    }
                }
                /* This frame is complete.
                 * Need to notify the VerifyStream continue.
                 * See the note in `AuthTag` for details.
                 * The short answer is that for small frame sizes,
                 * the "next" frame associated auth tag may be
                 * parsed and send before the "current" is processed.
                 * This will cause the auth tag event to fire before
                 * any _transform events fire and a 'Lengths do not match' precondition to fail.
                 */
                next();
                // This frame is complete. Notify _transform to continue, see needs above for more details
                if (frameComplete)
                    frameComplete();
                // reset for next frame.
                frameComplete = false;
            };
            this.on('pipe', (source) => {
                /* Precondition: The source must be a VerifyStream to emit the required events. */
                material_management_node_1.needs(source instanceof verify_stream_1.VerifyStream, 'Unsupported source');
                source
                    .once('DecipherInfo', (info) => {
                    decipherInfo = info;
                })
                    .on('BodyInfo', this._onBodyHeader)
                    .on('AuthTag', (authTag, next) => {
                    this._onAuthTag(authTag, next).catch((e) => this.emit('error', e));
                });
            });
        }
        _transform(chunk, _encoding, callback) {
            /* Precondition: BodyHeader must be parsed before frame data. */
            material_management_node_1.needs(decipherState.decipher, 'Malformed State.');
            decipherState.contentLength -= chunk.length;
            /* Precondition: Only content should be transformed, so the lengths must always match.
             * The BodyHeader and AuthTag are striped in the VerifyStream and passed in
             * through events.  This means that if I receive a chunk without having reset
             * the content accumulation events are out of order.  Panic.
             */
            material_management_node_1.needs(decipherState.contentLength >= 0, 'Lengths do not match');
            const { content } = decipherState;
            content.push(chunk);
            if (decipherState.contentLength > 0) {
                // More data to this frame
                callback();
            }
            else {
                // The frame is full, waiting for `AuthTag`
                // event to decrypt and forward the clear frame
                frameComplete = callback;
            }
        }
        _read(size) {
            /* The _onAuthTag decrypts and pushes the encrypted frame.
             * If this.push returns false then this stream
             * should wait until the destination stream calls read.
             * This means that _onAuthTag needs to wait for some
             * indeterminate time.  I create a closure around
             * the resolution function for a promise that
             * is created in _onAuthTag.  This way
             * here in _read (the implementation of read)
             * if a frame is being pushed, we can release
             * it.
             */
            pathologicalDrain();
            pathologicalDrain = noop;
            super._read(size);
        }
        _destroy() {
            // It is possible to have to destroy the stream before
            // decipherInfo is set.  Especially if the HeaderAuth
            // is not valid.
            decipherInfo && decipherInfo.dispose();
        }
    })();
}
exports.getDecipherStream = getDecipherStream;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjaXBoZXJfc3RyZWFtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2RlY2lwaGVyX3N0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsb0VBQW9FO0FBQ3BFLHNDQUFzQzs7O0FBRXRDLGFBQWE7QUFDYixxREFBZ0U7QUFFaEUsbUZBSTZDO0FBQzdDLHFEQUErRDtBQUMvRCxtREFBOEM7QUFFOUMsTUFBTSxRQUFRLEdBQUcsQ0FBQyxLQUFhLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFBO0FBQzlELE1BQU0sVUFBVSxHQUFHLHNCQUFVLENBQUMsUUFBUSxDQUFDLENBQUE7QUFDdkMsTUFBTSx5QkFBeUIsR0FBRywyQkFFcEIsQ0FBQTtBQXNCZCxNQUFNLE1BQU0sR0FBRyxLQUFLLElBQUksRUFBRSxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQTtBQUMxRSxNQUFNLElBQUksR0FBRyxHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUEsQ0FBQywyREFBMkQ7QUFFakYsU0FBZ0IsaUJBQWlCO0lBQy9CLElBQUksWUFBMEIsQ0FBQTtJQUM5QixJQUFJLGFBQWEsR0FBa0IsRUFBUyxDQUFBO0lBQzVDLElBQUksaUJBQWlCLEdBQTJCLElBQUksQ0FBQTtJQUNwRCxJQUFJLGFBQWEsR0FBb0MsS0FBSyxDQUFBO0lBRTFELE9BQU8sSUFBSSxDQUFDLE1BQU0sY0FBZSxTQUFRLHlCQUF5QjtRQUNoRTtZQUNFLEtBQUssRUFBRSxDQUFBO1lBZVQsa0JBQWEsR0FBRyxDQUFDLEVBQ2YsRUFBRSxFQUNGLGFBQWEsRUFDYixjQUFjLEVBQ2QsWUFBWSxHQUNILEVBQUUsRUFBRTtnQkFDYixxRUFBcUU7Z0JBQ3JFLGdDQUFLLENBQUMsWUFBWSxFQUFFLGtCQUFrQixDQUFDLENBQUE7Z0JB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