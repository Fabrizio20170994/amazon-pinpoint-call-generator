"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParseHeaderStream = void 0;
// @ts-ignore
const readable_stream_1 = require("readable-stream");
const material_management_node_1 = require("@aws-crypto/material-management-node");
const serialize_1 = require("@aws-crypto/serialize");
const toUtf8 = (input) => Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString('utf8');
const deserialize = serialize_1.deserializeFactory(toUtf8, material_management_node_1.NodeAlgorithmSuite);
const PortableTransformWithType = readable_stream_1.Transform;
class ParseHeaderStream extends PortableTransformWithType {
    constructor(signaturePolicy, { commitmentPolicy, maxEncryptedDataKeys }, cmm) {
        super();
        /* Precondition: ParseHeaderStream needs a valid commitmentPolicy. */
        material_management_node_1.needs(material_management_node_1.CommitmentPolicy[commitmentPolicy], 'Invalid commitment policy.');
        /* Precondition: ParseHeaderStream needs a valid signaturePolicy. */
        material_management_node_1.needs(material_management_node_1.SignaturePolicy[signaturePolicy], 'Invalid signature policy.');
        // buildDecrypt defaults this to false for backwards compatibility, so this is satisfied
        /* Precondition: ParseHeaderStream needs a valid maxEncryptedDataKeys. */
        material_management_node_1.needs(maxEncryptedDataKeys === false || maxEncryptedDataKeys >= 1, 'Invalid maxEncryptedDataKeys value.');
        Object.defineProperty(this, 'materialsManager', {
            value: cmm,
            enumerable: true,
        });
        Object.defineProperty(this, 'commitmentPolicy', {
            value: commitmentPolicy,
            enumerable: true,
        });
        Object.defineProperty(this, 'maxEncryptedDataKeys', {
            value: maxEncryptedDataKeys,
            enumerable: true,
        });
        this._headerState = {
            buffer: Buffer.alloc(0),
            headerParsed: false,
        };
        Object.defineProperty(this, 'signaturePolicy', {
            value: signaturePolicy,
            enumerable: true,
        });
    }
    _transform(
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    chunk, encoding, callback) {
        try {
            const { _headerState, commitmentPolicy, materialsManager, signaturePolicy, maxEncryptedDataKeys, } = this;
            const { buffer } = _headerState;
            const headerBuffer = Buffer.concat([buffer, chunk]);
            const headerInfo = deserialize.deserializeMessageHeader(headerBuffer, {
                maxEncryptedDataKeys,
            });
            if (!headerInfo) {
                _headerState.buffer = headerBuffer;
                return callback();
            }
            const { messageHeader, algorithmSuite } = headerInfo;
            const messageIDStr = Buffer.from(messageHeader.messageId).toString('hex');
            /* Precondition: The parsed header algorithmSuite from ParseHeaderStream must be supported by the commitmentPolicy. */
            material_management_node_1.CommitmentPolicySuites.isDecryptEnabled(commitmentPolicy, algorithmSuite, messageIDStr);
            /* Precondition: The parsed header algorithmSuite from ParseHeaderStream must be supported by the signaturePolicy. */
            material_management_node_1.SignaturePolicySuites.isDecryptEnabled(signaturePolicy, algorithmSuite, messageIDStr);
            const { rawHeader, headerAuth } = headerInfo;
            const { headerIv, headerAuthTag, headerAuthLength } = headerAuth;
            const suite = new material_management_node_1.NodeAlgorithmSuite(algorithmSuite.id);
            const { messageId, encryptionContext, encryptedDataKeys } = messageHeader;
            materialsManager
                .decryptMaterials({ suite, encryptionContext, encryptedDataKeys })
                .then((material) => {
                /* Precondition: The material algorithmSuite returned to ParseHeaderStream must be supported by the commitmentPolicy. */
                material_management_node_1.CommitmentPolicySuites.isDecryptEnabled(commitmentPolicy, material.suite, messageIDStr);
                /* Precondition: The material algorithmSuite returned to ParseHeaderStream must be supported by the signaturePolicy. */
                material_management_node_1.SignaturePolicySuites.isDecryptEnabled(signaturePolicy, material.suite, messageIDStr);
                _headerState.buffer = Buffer.alloc(0); // clear the Buffer...
                const { getDecipherInfo, getVerify, dispose } = material_management_node_1.getDecryptionHelper(material);
                const getDecipher = getDecipherInfo(messageId, 
                /* This is sub-optimal.
                 * Ideally I could pluck the `suiteData`
                 * right off the header
                 * and in such a way that may be undefined.
                 * But that has other consequences
                 * that are beyond the scope of this course.
                 */
                messageHeader.suiteData);
                const headerAuth = getDecipher(headerIv);
                headerAuth.setAAD(Buffer.from(rawHeader.buffer, rawHeader.byteOffset, rawHeader.byteLength));
                headerAuth.setAuthTag(Buffer.from(headerAuthTag.buffer, headerAuthTag.byteOffset, headerAuthTag.byteLength));
                headerAuth.update(Buffer.alloc(0));
                headerAuth.final(); // will throw if invalid
                const verify = getVerify ? getVerify() : void 0;
                const verifyInfo = {
                    headerInfo,
                    getDecipher,
                    verify,
                    dispose,
                };
                this.emit('VerifyInfo', verifyInfo);
                this.emit('MessageHeader', headerInfo.messageHeader);
                _headerState.headerParsed = true;
                // The header is parsed, pass control
                const readPos = rawHeader.byteLength + headerAuthLength;
                const tail = headerBuffer.slice(readPos);
                /* needs calls in downstream _transform streams will throw.
                 * But streams are async.
                 * So this error should be turned into an `.emit('error', ex)`.
                 */
                this._transform = (chunk, _enc, cb) => {
                    try {
                        cb(null, chunk);
                    }
                    catch (ex) {
                        this.emit('error', ex);
                    }
                };
                // flush the tail.  Stream control is now in the verify and decrypt streams
                return setImmediate(() => this._transform(tail, encoding, callback));
            })
                .catch((err) => callback(err));
        }
        catch (ex) {
            /* Exceptional Postcondition: An error MUST be emitted or this would be an unhandled exception. */
            this.emit('error', ex);
        }
    }
    _flush(callback) {
        /* Postcondition: A completed header MUST have been processed.
         * callback is an errBack function,
         * so it expects either an error OR undefined
         */
        callback(this._headerState.headerParsed
            ? undefined
            : new Error('Incomplete Header'));
    }
}
exports.ParseHeaderStream = ParseHeaderStream;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VfaGVhZGVyX3N0cmVhbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZV9oZWFkZXJfc3RyZWFtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxvRUFBb0U7QUFDcEUsc0NBQXNDOzs7QUFFdEMsYUFBYTtBQUNiLHFEQUFnRTtBQUVoRSxtRkFVNkM7QUFDN0MscURBQTJFO0FBRzNFLE1BQU0sTUFBTSxHQUFHLENBQUMsS0FBaUIsRUFBRSxFQUFFLENBQ25DLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUE7QUFDaEYsTUFBTSxXQUFXLEdBQUcsOEJBQWtCLENBQUMsTUFBTSxFQUFFLDZDQUFrQixDQUFDLENBQUE7QUFDbEUsTUFBTSx5QkFBeUIsR0FBRywyQkFFcEIsQ0FBQTtBQU9kLE1BQWEsaUJBQWtCLFNBQVEseUJBQXlCO0lBTTlELFlBQ0UsZUFBZ0MsRUFDaEMsRUFBRSxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBaUIsRUFDekQsR0FBeUI7UUFFekIsS0FBSyxFQUFFLENBQUE7UUFFUCxxRUFBcUU7UUFDckUsZ0NBQUssQ0FBQywyQ0FBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLDRCQUE0QixDQUFDLENBQUE7UUFFdkUsb0VBQW9FO1FBQ3BFLGdDQUFLLENBQUMsMENBQWUsQ0FBQyxlQUFlLENBQUMsRUFBRSwyQkFBMkIsQ0FBQyxDQUFBO1FBRXBFLHdGQUF3RjtRQUN4Rix5RUFBeUU7UUFDekUsZ0NBQUssQ0FDSCxvQkFBb0IsS0FBSyxLQUFLLElBQUksb0JBQW9CLElBQUksQ0FBQyxFQUMzRCxxQ0FBcUMsQ0FDdEMsQ0FBQTtRQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLGtCQUFrQixFQUFFO1lBQzlDLEtBQUssRUFBRSxHQUFHO1lB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