"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEncryptFrame = exports.getFramedEncryptStream = void 0;
const serialize_1 = require("@aws-crypto/serialize");
// @ts-ignore
const readable_stream_1 = require("readable-stream");
const material_management_node_1 = require("@aws-crypto/material-management-node");
const fromUtf8 = (input) => Buffer.from(input, 'utf8');
const serialize = serialize_1.serializeFactory(fromUtf8);
const { finalFrameHeader, frameHeader } = serialize;
const aadUtility = serialize_1.aadFactory(fromUtf8);
const PortableTransformWithType = readable_stream_1.Transform;
const ioTick = async () => new Promise((resolve) => setImmediate(resolve));
const noop = () => { }; // eslint-disable-line @typescript-eslint/no-empty-function
function getFramedEncryptStream(getCipher, messageHeader, dispose, { plaintextLength, suite, }) {
    let accumulatingFrame = {
        contentLength: 0,
        content: [],
        sequenceNumber: 1,
    };
    let pathologicalDrain = noop;
    const { frameLength } = messageHeader;
    /* Precondition: plaintextLength must be within bounds.
     * The Maximum.BYTES_PER_MESSAGE is set to be within Number.MAX_SAFE_INTEGER
     * See serialize/identifiers.ts enum Maximum for more details.
     */
    material_management_node_1.needs(!plaintextLength ||
        (plaintextLength >= 0 && serialize_1.Maximum.BYTES_PER_MESSAGE >= plaintextLength), 'plaintextLength out of bounds.');
    /* Keeping the messageHeader, accumulatingFrame and pathologicalDrain private is the intention here.
     * It is already unlikely that these values could be touched in the current composition of streams,
     * but a different composition may change this.
     * Since we are handling the plain text here, it seems prudent to take extra measures.
     */
    return new (class FramedEncryptStream extends PortableTransformWithType {
        _transform(chunk, encoding, callback) {
            const contentLeft = frameLength - accumulatingFrame.contentLength;
            /* Precondition: Must not process more than plaintextLength.
             * The plaintextLength is the MAXIMUM value that can be encrypted.
             */
            material_management_node_1.needs(!plaintextLength || (plaintextLength -= chunk.length) >= 0, 'Encrypted data exceeded plaintextLength.');
            /* Check for early return (Postcondition): Have not accumulated a frame. */
            if (contentLeft > chunk.length) {
                // eat more
                accumulatingFrame.contentLength += chunk.length;
                accumulatingFrame.content.push(chunk);
                return callback();
            }
            accumulatingFrame.contentLength += contentLeft;
            accumulatingFrame.content.push(chunk.slice(0, contentLeft));
            // grab the tail
            const tail = chunk.slice(contentLeft);
            const encryptFrame = getEncryptFrame({
                pendingFrame: accumulatingFrame,
                messageHeader,
                getCipher,
                isFinalFrame: false,
                suite,
            });
            // Reset frame state for next frame
            const { sequenceNumber } = accumulatingFrame;
            accumulatingFrame = {
                contentLength: 0,
                content: [],
                sequenceNumber: sequenceNumber + 1,
            };
            this._flushEncryptFrame(encryptFrame)
                .then(() => this._transform(tail, encoding, callback))
                .catch(callback);
        }
        _flush(callback) {
            const encryptFrame = getEncryptFrame({
                pendingFrame: accumulatingFrame,
                messageHeader,
                getCipher,
                isFinalFrame: true,
                suite,
            });
            this._flushEncryptFrame(encryptFrame)
                .then(() => callback())
                .catch(callback);
        }
        _destroy() {
            dispose();
        }
        _read(size) {
            super._read(size);
            /* The _flushEncryptFrame encrypts and pushes the frame.
             * If this.push returns false then this stream
             * should wait until the destination stream calls read.
             * This means that _flushEncryptFrame needs to wait for some
             * indeterminate time.  I create a closure around
             * the resolution function for a promise that
             * is created in _flushEncryptFrame.  This way
             * here in _read (the implementation of read)
             * if a frame is being pushed, we can release
             * it.
             */
            pathologicalDrain();
            pathologicalDrain = noop;
        }
        async _flushEncryptFrame(encryptingFrame) {
            const { content, cipher, bodyHeader, isFinalFrame } = encryptingFrame;
            this.push(bodyHeader);
            let frameSize = 0;
            const cipherContent = [];
            for (const clearChunk of content) {
                const cipherText = cipher.update(clearChunk);
                frameSize += cipherText.length;
                cipherContent.push(cipherText);
                await ioTick();
            }
            /* Finalize the cipher and handle any tail. */
            const tail = cipher.final();
            frameSize += tail.length;
            cipherContent.push(tail);
            /* Push the authTag onto the end.  Yes, I am abusing the name. */
            cipherContent.push(cipher.getAuthTag());
            material_management_node_1.needs(frameSize === frameLength || (isFinalFrame && frameLength >= frameSize), 'Malformed frame');
            for (const cipherText of cipherContent) {
                if (!this.push(cipherText)) {
                    /* back pressure: if push returns false, wait until _read
                     * has been called.
                     */
                    await new Promise((resolve) => {
                        pathologicalDrain = resolve;
                    });
                }
            }
            if (isFinalFrame)
                this.push(null);
        }
    })();
}
exports.getFramedEncryptStream = getFramedEncryptStream;
function getEncryptFrame(input) {
    const { pendingFrame, messageHeader, getCipher, isFinalFrame, suite } = input;
    const { sequenceNumber, contentLength, content } = pendingFrame;
    const { frameLength, contentType, messageId } = messageHeader;
    /* Precondition: The content length MUST correlate with the frameLength.
     * In the case of a regular frame,
     * the content length MUST strictly equal the frame length.
     * In the case of the final frame,
     * it MUST NOT be larger than the frame length.
     */
    material_management_node_1.needs(frameLength === contentLength ||
        (isFinalFrame && frameLength >= contentLength), `Malformed frame length and content length: ${JSON.stringify({
        frameLength,
        contentLength,
        isFinalFrame,
    })}`);
    const frameIv = serialize.frameIv(suite.ivLength, sequenceNumber);
    const bodyHeader = Buffer.from(isFinalFrame
        ? finalFrameHeader(sequenceNumber, frameIv, contentLength)
        : frameHeader(sequenceNumber, frameIv));
    const contentString = aadUtility.messageAADContentString({
        contentType,
        isFinalFrame,
    });
    const { buffer, byteOffset, byteLength } = aadUtility.messageAAD(messageId, contentString, sequenceNumber, contentLength);
    const cipher = getCipher(frameIv);
    cipher.setAAD(Buffer.from(buffer, byteOffset, byteLength));
    return { content, cipher, bodyHeader, isFinalFrame };
}
exports.getEncryptFrame = getEncryptFrame;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJhbWVkX2VuY3J5cHRfc3RyZWFtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ZyYW1lZF9lbmNyeXB0X3N0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsb0VBQW9FO0FBQ3BFLHNDQUFzQzs7O0FBRXRDLHFEQUs4QjtBQUM5QixhQUFhO0FBQ2IscURBQWdFO0FBRWhFLG1GQUs2QztBQUU3QyxNQUFNLFFBQVEsR0FBRyxDQUFDLEtBQWEsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUE7QUFDOUQsTUFBTSxTQUFTLEdBQUcsNEJBQWdCLENBQUMsUUFBUSxDQUFDLENBQUE7QUFDNUMsTUFBTSxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxHQUFHLFNBQVMsQ0FBQTtBQUNuRCxNQUFNLFVBQVUsR0FBRyxzQkFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFBO0FBZXZDLE1BQU0seUJBQXlCLEdBQUcsMkJBRXBCLENBQUE7QUFFZCxNQUFNLE1BQU0sR0FBRyxLQUFLLElBQUksRUFBRSxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQTtBQUMxRSxNQUFNLElBQUksR0FBRyxHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUEsQ0FBQywyREFBMkQ7QUFHakYsU0FBZ0Isc0JBQXNCLENBQ3BDLFNBQW9CLEVBQ3BCLGFBQTRCLEVBQzVCLE9BQW1CLEVBQ25CLEVBQ0UsZUFBZSxFQUNmLEtBQUssR0FDbUQ7SUFFMUQsSUFBSSxpQkFBaUIsR0FBc0I7UUFDekMsYUFBYSxFQUFFLENBQUM7UUFDaEIsT0FBTyxFQUFFLEVBQUU7UUFDWCxjQUFjLEVBQUUsQ0FBQztLQUNsQixDQUFBO0lBQ0QsSUFBSSxpQkFBaUIsR0FBMkIsSUFBSSxDQUFBO0lBQ3BELE1BQU0sRUFBRSxXQUFXLEVBQUUsR0FB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